
use crate::backend::kdsl_bridge;
#[cfg(feature="logic")]
use st_logic::{solve_soft, Ctx as LCtx, SolveCfg as LCfg, SoftRule};

#[derive(Debug, Clone, Copy)]
pub struct Choice { pub use_2ce: bool, pub wg: u32, pub kl: u32, pub ch: u32 }

fn fallback(_rows:u32, cols:u32, k:u32, sg:bool)->Choice{
    Choice{
        use_2ce: cols>32768 || k>128,
        wg: if sg {256} else {128},
        kl: if k>=64 {32} else if k>=16 {16} else {8},
        ch: if cols>16384 {8192} else {0},
    }
}

pub fn choose(rows: u32, cols: u32, k: u32, subgroup: bool) -> Choice {
    let (hard_from_dsl, soft_rules): (Option<Choice>, Vec<SoftRule>) = {
        kdsl_bridge::parse_env_dsl(rows, cols, k, subgroup)
    };

    #[cfg(feature="logic")]
    {
        if std::env::var("SPIRAL_HEUR_SOFT").ok().map(|v| v=="1").unwrap_or(true) {
            let ctx = LCtx { rows, cols, k, sg: subgroup };
            let (c, score) = solve_soft(ctx, LCfg{ noise: 0.02, seed: 0x5p1ral }, &soft_rules);
            if score > 0.1 {
                return Choice{ use_2ce:c.use_2ce, wg:c.wg, kl:c.kl, ch:c.ch };
            }
        }
    }

    if let Some(c)=hard_from_dsl { return c; }

    if let Some(c)=choose_generated(rows, cols, k, subgroup) { return c; }

    if let Some(c)=kdsl_bridge::choose_from_kv(rows, cols, k, subgroup) { return c; }

    fallback(rows, cols, k, subgroup)
}

// Generated by tuner (stub by default)
include!("wgpu_heuristics_generated.rs");
