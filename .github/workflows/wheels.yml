name: Wheels
on:
  push:
    tags: [ 'v*' ]
  workflow_dispatch:

jobs:
  build-wheels:
    runs-on: ${{ matrix.os }}
    defaults:
      run:
        shell: bash
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            label: macos-latest-macosx14-universal2
            macos_deployment_target: "14.0"
            universal2: true
            py: "3.12"
            feat: "wgpu,logic,kdsl"
          - os: ubuntu-22.04
            label: ubuntu-22.04
            macos_deployment_target: ""
            universal2: false
            py: "3.12"
            feat: "wgpu,logic,kdsl"
          - os: windows-2022
            label: windows-2022
            macos_deployment_target: ""
            universal2: false
            py: "3.12"
            feat: "wgpu,logic,kdsl"
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.py }}
      - name: Set macOS deployment target
        if: matrix.macos_deployment_target != ''
        run: echo "MACOSX_DEPLOYMENT_TARGET=${{ matrix.macos_deployment_target }}" >> "$GITHUB_ENV"
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      - name: Install macOS universal2 targets
        if: runner.os == 'macOS' && matrix.universal2 == true
        run: rustup target add aarch64-apple-darwin x86_64-apple-darwin
      - name: Build wheel
        run: |
          python -m pip install -U pip wheel maturin
          extra_args=""
          if [ "${{ matrix.universal2 }}" = "true" ]; then
            extra_args="$extra_args --universal2"
          fi
          if [ "${{ runner.os }}" = "Linux" ]; then
            maturin build --release --locked --manylinux 2014 -m bindings/st-py/Cargo.toml --features "${{ matrix.feat }}"
          else
            maturin build --release --locked $extra_args -m bindings/st-py/Cargo.toml --features "${{ matrix.feat }}"
          fi
      - name: Smoke test wheel import
        working-directory: target/wheels
        env:
          PYTHONNOUSERSITE: "1"
        run: |
          python -m pip install --force-reinstall --no-cache-dir spiraltorch-*.whl
          python - <<'PY'
          import spiraltorch as st

          print("import ok:", len(getattr(st, "__all__", ())))
          assert hasattr(st, "optim")
          assert hasattr(st.optim, "Amegagrad")

          opt = st.optim.Amegagrad((1, 3), curvature=-0.9, hyper_learning_rate=0.03, real_learning_rate=0.02)
          weights = st.Tensor(1, 3, [0.2, -0.1, 0.05])
          opt.accumulate_wave(st.Tensor(1, 3, [0.4, -0.6, 0.2]))
          before = weights.tolist()
          opt.step(weights, tune=False)
          after = weights.tolist()
          assert after != before

          trainer = st.ZSpaceTrainer(z_dim=4)
          loss = trainer.step(
              {"speed": 0.2, "memory": 0.1, "stability": 0.9, "gradient": opt.real.gradient()}
          )
          float(loss)
          partial_loss = trainer.step_partial(
              {"speed": 0.15, "memory": 0.1, "stability": 0.92, "gradient": [0.1, 0.0, 0.0, 0.0]}
          )
          float(partial_loss)
          assert trainer.last_inference is not None

          assert hasattr(st, "LanguageWaveEncoder")
          encoder = st.LanguageWaveEncoder(-1.0, 0.5)
          probe = encoder.encode_z_space("SpiralTorch")
          rows, cols = probe.shape()
          text_opt = st.optim.Amegagrad((rows, cols), curvature=float(encoder.curvature()))
          text_weights = st.Tensor(rows, cols, [0.0] * (rows * cols))
          text_opt.absorb_text(encoder, "SpiralTorch wheels smoke test")
          before = text_weights.tolist()
          control = text_opt.desire_control()
          text_opt.step(text_weights, tune=True, control=control)
          after = text_weights.tolist()
          assert after != before

          info = st.build_info()
          assert isinstance(info, dict)
          assert info.get("package") == "spiraltorch-py"

          projector = st.canvas.CanvasProjector(width=16, height=16, palette="turbo")
          projector.push_patch(st.Tensor(16, 16, [0.0] * 256), coherence=1.0, tension=1.0, depth=0)
          projector.refresh_rgba()
          patch = projector.emit_zspace_patch(coherence=1.0, tension=1.0, depth=0)
          assert patch["relation"].shape() == (16, 16)
          projector.push_patch(patch["relation"], coherence=patch["coherence"], tension=patch["tension"], depth=patch["depth"])
          trail = projector.emit_wasm_trail(curvature=1.5)
          assert trail["samples"].shape() == (16 * 16, 7)
          frame = projector.emit_atlas_frame(prefix="canvas", refresh=False, timestamp=0.0)
          assert isinstance(frame.timestamp, float)

          patch_packet = st.canvas.emit_zspace_patch_packet(projector, coherence=1.0, tension=1.0, depth=0)
          assert patch_packet.relation.shape() == (16, 16)
          trail_packet = st.canvas.emit_wasm_trail_packet(projector, curvature=1.5)
          assert trail_packet.samples.shape() == (16 * 16, 7)

          route = st.telemetry.AtlasRoute()
          route.push_bounded(st.telemetry.AtlasFrame.from_metrics({"psi.total": 1.0}, timestamp=0.0), bound=8)
          route.push_bounded(st.telemetry.AtlasFrame.from_metrics({"psi.total": 1.5}, timestamp=1.0), bound=8)
          route.push_bounded(frame, bound=8)
          assert route.perspective_for("Concourse", focus_prefixes=["psi."]) is not None
          assert isinstance(route.beacons(limit=4), list)
          perspective_packet = st.telemetry.perspective_for_packet(route, "Concourse", focus_prefixes=["psi."])
          assert perspective_packet is not None
          assert isinstance(perspective_packet.guidance, str)

          session = st.amegagrad_session((1, 4), curvature=-0.9, telemetry=True, telemetry_bound=8)
          session.step_wave(st.Tensor(1, 4, [0.1, -0.2, 0.05, 0.0]))

          import tempfile
          import pathlib
          import json
          import time as _time

          with tempfile.TemporaryDirectory() as td:
              td_path = pathlib.Path(td)
              trace_path = td_path / "trace.jsonl"
              trace_event = {
                  "type": "ZSpaceTrace",
                  "event_type": "ZSpaceTrace",
                  "payload": {"ZSpaceCoherence": {"step": 0, "coherence": [0.1, 0.2]}},
              }
              trace_path.write_text(json.dumps(trace_event) + "\n", encoding="utf-8")
              html_path = st.write_zspace_trace_html(trace_path, td_path / "trace.html")
              assert pathlib.Path(html_path).exists()

          plan = st.plan_topk(rows=1024, cols=16384, k=32, backend="cpu")
          ctx = plan.spiralk_context()
          out, trace = ctx.eval_with_trace("wg: 128;", 64)
          assert isinstance(out, dict)
          assert isinstance(trace, dict)
          plan2, out2, trace2 = plan.rewrite_with_spiralk_explain("wg: 128;", max_events=64)
          assert isinstance(plan2, st.RankPlan)
          assert isinstance(out2, dict)
          assert isinstance(trace2, dict)

          with tempfile.TemporaryDirectory() as td:
              td_path = pathlib.Path(td)
              kdsl_jsonl = st.write_kdsl_trace_jsonl(trace2, td_path / "kdsl.jsonl")
              kdsl_html = st.write_kdsl_trace_html(trace2, td_path / "kdsl.html")
              assert pathlib.Path(kdsl_jsonl).exists()
              assert pathlib.Path(kdsl_html).exists()

          live = st.serve_zspace_trace(open_browser=False, background=True, poll_interval=0.01, max_batch=1, buffer=1)
          _time.sleep(0.05)
          live.close()
          live.join(2.0)

          print("smoke ok")
          PY
      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: wheel-${{ matrix.label }}-py${{ matrix.py }}-${{ matrix.feat }}
          path: target/wheels/*.whl
