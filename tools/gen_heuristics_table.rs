
use std::{fs};
use serde::Deserialize;

#[derive(Deserialize)]
struct SampleTop {
    rows: usize, cols: usize, k: usize, subgroup: bool,
    use_2ce: bool, wg: u32, kl: u32, ch: u32,
    time_ms: f32,
}
#[derive(Deserialize)]
struct SampleMidK {
    rows: usize, cols: usize, k: usize, subgroup: bool,
    scan_wg: u32, tile_cols: u32, two_ce: bool,
    time_ms: f32,
}
#[derive(Deserialize)]
struct TunerJson {
    topk: Option<Vec<SampleTop>>,
    midk: Option<Vec<SampleMidK>>,
}

fn bin_log2(x: usize)->u32 {
    let v = x.max(1);
    (usize::BITS - (v-1).leading_zeros()) - 1
}

fn gen_topk(samples:&[SampleTop]) -> String {
    use std::collections::HashMap;
    let mut best: HashMap<(bool,u32,u32),(f32,(bool,u32,u32,u32))> = HashMap::new();
    for s in samples {
        let key = (s.subgroup, bin_log2(s.cols), bin_log2(s.k));
        let val = (s.time_ms, (s.use_2ce, s.wg, s.kl, s.ch));
        best.entry(key).and_modify(|old|{ if val.0 < old.0 { *old = val; } }).or_insert(val);
    }
    let mut lines = String::new();
    lines.push_str("// auto-generated by tools/gen_heuristics_table.rs\n");
    lines.push_str("pub(super) fn choose(\n    rows: u32, cols: u32, k: u32, subgroup: bool\n) -> Option<super::Choice> {\n");
    lines.push_str("    let lg2c = (32 - (cols.max(1)-1).leading_zeros());\n");
    lines.push_str("    let lg2k = (32 - (k.max(1)-1).leading_zeros());\n");
    lines.push_str("    match (subgroup, lg2c, lg2k) {\n");
    let mut keyed: Vec<_> = best.into_iter().collect();
    keyed.sort_by_key(|((sg,lg2c,lg2k),_)| (*sg as u8, *lg2c, *lg2k));
    for ((sg, lg2c, lg2k), (_, (u2, wg, kl, ch))) in keyed {
        lines.push_str(&format!("        ({},{},{}) => Some(super::Choice{{ use_2ce:{}, wg:{}, kl:{}, ch:{} }}),\n",
            if sg {"true"} else {"false"}, lg2c, lg2k, u2, wg, kl, ch));
    }
    lines.push_str("        _ => None,\n    }\n}\n");
    lines
}

fn gen_midk(samples:&[SampleMidK]) -> String {
    use std::collections::HashMap;
    let mut best: HashMap<(bool,u32,u32),(f32,(u32,u32,bool))> = HashMap::new();
    for s in samples {
        let key = (s.subgroup, bin_log2(s.cols), bin_log2(s.k));
        let val = (s.time_ms, (s.scan_wg, s.tile_cols, s.two_ce));
        best.entry(key).and_modify(|old|{ if val.0 < old.0 { *old = val; } }).or_insert(val);
    }
    let mut lines = String::new();
    lines.push_str("// auto-generated by tools/gen_heuristics_table.rs\n");
    lines.push_str("pub(super) fn choose_generated_midk(\n    rows: u32, cols: u32, k: u32, subgroup: bool\n) -> Option<super::MidKChoice> {\n");
    lines.push_str("    let lg2c = (32 - (cols.max(1)-1).leading_zeros());\n");
    lines.push_str("    let lg2k = (32 - (k.max(1)-1).leading_zeros());\n");
    lines.push_str("    match (subgroup, lg2c, lg2k) {\n");
    let mut keyed: Vec<_> = best.into_iter().collect();
    keyed.sort_by_key(|((sg,lg2c,lg2k),_)| (*sg as u8, *lg2c, *lg2k));
    for ((sg, lg2c, lg2k), (_, (wg, tile, u2))) in keyed {
        lines.push_str(&format!("        ({},{},{}) => Some(super::MidKChoice{{ scan_wg:{}, tile_cols:{}, two_ce:{} }}),\n",
            if sg {"true"} else {"false"}, lg2c, lg2k, wg, tile, if u2 {"true"} else {"false"}));
    }
    lines.push_str("        _ => None,\n    }\n}\n");
    lines
}

fn main(){
    let args: Vec<String> = std::env::args().collect();
    if args.len()<4 {
        eprintln!("Usage: gen_heuristics_table <tuner.json> <out_topk.rs> <out_midk.rs>");
        std::process::exit(1);
    }
    let js = fs::read_to_string(&args[1]).expect("read tuner.json");
    let data: TunerJson = serde_json::from_str(&js).expect("parse tuner.json");
    if let Some(top) = data.topk.as_ref() {
        let s = gen_topk(top);
        fs::write(&args[2], s).expect("write topk table");
    }
    if let Some(midk) = data.midk.as_ref() {
        let s = gen_midk(midk);
        fs::write(&args[3], s).expect("write midk table");
    }
}
